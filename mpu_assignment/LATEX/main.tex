\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{listings}
\usepackage{xcolor}  % Include xcolor for text color
\usepackage{abstract}
\usepackage{float}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{siunitx}
\usepackage{caption}


\title{Embedded control with movement detection: \\ Utilizing MPU9250, MQTT, Node-RED, and InfluxDB and machine learning in esp32.}
\author{Nikolaos Mouzakitis}
\date{May 21, 2025}

\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegray},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\maketitle

\section{Introduction}

This project integrates an ESP32 microcontroller with an MPU9250 
inertial measurement unit (IMU) sensor to detect device movements 
and control 2 LEDs and PWM outputs accordingly. 
It implements a mechanism to persist and restore device state 
via MQTT messaging, Node-RED flow processing, and data storage in an InfluxDB time-series database.

The key 
functionalities are:

\begin{itemize}
    \item Reading accelerometer and gyroscope Y-axis data from the MPU9250.
    \item Applying threshold-based logic or machine learning to detect movement and determine LED and PWM states.
    \item Publishing device status data over MQTT.
    \item Restoring device LED and PWM states after reboot using InfluxDB queries and Node-RED.
\end{itemize}

\section{MPU9250 Sensor Data and Movement Detection}

\subsection{Sensor Overview}

The MPU9250 is a 9-axis IMU sensor combining a 3-axis accelerometer, 
3-axis gyroscope, and 3-axis magnetometer. 
For this project, only the accelerometer Y-axis and gyroscope Y-axis values 
are utilized.

\subsection{Data Acquisition}

The ESP32 reads raw sensor values for accelerometer Y (\texttt{ay}) 
and gyroscope Y (\texttt{gy}) at periodic intervals.

\subsection{Threshold-Based Movement Detection}

Threshold values are defined empirically to decide when the ESP32 should 
change the states of its LEDs and PWM output.


\subsection{Controlling LEDs and PWM}

Based on movement detection, the device sets the LEDs and PWM.

\subsection{Status Publishing}

The ESP32 publishes its current LED and PWM states 
on the MQTT topic \texttt{esp32/status} as a formatted string:

{\scriptsize
\begin{verbatim}
LED1:OFF LED2:ON PWM:15
\end{verbatim}
}
This message serves to provide the
real-time status of device outputs.

\section{MQTT Communication Architecture}

The ESP32 communicates with the Node-RED 
server via MQTT. Topics used include:

\begin{itemize}
    \item \texttt{esp32/status} — Periodic status updates including LED and PWM states.
    \item \texttt{esp32/restore\_request} — Sent by ESP32 at startup requesting last stored device state.
    \item \texttt{esp32/restore\_state} — Published by Node-RED after querying InfluxDB with the restore state data.
\end{itemize}

\subsection{Restore request and response flow}

Upon powering on, on startup, 
the ESP32 immediately publishes a \texttt{get\_latest} message 
on \texttt{esp32/restore\_request}. 
This triggers Node-RED to query the latest device state 
stored in InfluxDB and respond by publishing a 
formatted restore state message on \texttt{esp32/restore\_state}.

The ESP32 listens for this restore message and 
applies the LED and PWM settings accordingly before 
continuing normal operation.
Restoration can be observed in the following Figure, where the Esp32 
boots and assigns immidiately the latest saved state on the LEDs.

		\begin{figure}[H]
			\centering
			\includegraphics[width=0.9\textwidth]{restore.png}
			\caption{Latest state restoration as observed over UART}
			\label{fig1:}
		\end{figure}		



\section{Node-RED and InfluxDB Integration}

\subsection{Node-RED Flow Design}

Node-RED acts as the middleware for the bridging of MQTT and InfluxDB:

\begin{enumerate}
    \item \textbf{MQTT In node} listens on \texttt{esp32/restore\_request} and 
	    detects the \texttt{get\_latest} message.
    \item \textbf{InfluxDB Query node} performs a time-series query 
	    fetching the most recent LED and PWM state values.
    \item \textbf{Function node} formats the InfluxDB query response 
	    into the MQTT payload string.
    \item \textbf{MQTT Out node} publishes the 
	    formatted message on \texttt{esp32/restore\_state}.
\end{enumerate}


		\begin{figure}[H]
			\centering
			\includegraphics[width=0.9\textwidth]{node1.png}
			\caption{Node-Red data and processing flow}
			\label{fig1:}
		\end{figure}		



\subsection{InfluxDB Query}

As for the InfluxDB, version 1.6.4 has been utilized and installed
as 
{\scriptsize
\begin{verbatim} 
echo "deb https://repos.influxdata.com/ubuntu bionic stable" |  sudo tee /etc/apt/sources.list.d/influxdb.list
sudo curl -sL https://repos.influxdata.com/influxdb.key | sudo apt-key add -
sudo apt get update
sudo apt-get install -y influxdb
\end{verbatim}
}
After installation, a database is created to be used for this project.

{\scriptsize
\begin{verbatim}
influx
> create database esp32db
\end{verbatim}
}

In \texttt{function3} of the Node-Red then, when run the following 
Javascript code in order to push data in the same database.

{\scriptsize
\begin{verbatim}
let parts = msg.payload.split(" ");
let led1 = parts[0].split(":")[1] === "ON" ? 1 : 0;
let led2 = parts[1].split(":")[1] === "ON" ? 1 : 0;
let pwm = parseInt(parts[2].split(":")[1]);

msg.payload = {
    LED1: led1,
    LED2: led2,
    PWM: pwm
};
msg.measurement = "led_status";
return msg;
\end{verbatim}
}

On the InfluxDb out node in Node-Red is also specified and set
the measurement's name as "led\_status" and 
on the server configuration the
respective host ip, port number and database name as "esp32db".



The InfluxDB query used in \texttt{create\_restore\_query} node is:

{\scriptsize
\begin{verbatim}
msg.query = 'SELECT LAST("LED1"), LAST("LED2"), LAST("PWM") FROM "led_status"';
return msg;
\end{verbatim}
}
This query retrieves the most recent LED1, LED2, and PWM values stored.

In the \texttt{restore payload formating} node of Node-Red
response if formated to be given as an input on the \texttt{restore\_state} topic as:

{\scriptsize
\begin{verbatim}
let row = msg.payload[0]; // first row of result

let LED1 = row.last === 1 ? "ON" : "OFF";
let LED2 = row.last_1 === 1 ? "ON" : "OFF";
let PWM = row.last_2;

msg.payload = `LED1:${LED1} LED2:${LED2} PWM:${PWM}`;
msg.topic = "esp32/restore_state";
return msg;
\end{verbatim}
}

\subsection{State Restoration}

Upon receiving the restore payload, the ESP32 parses the string and applies the saved LED and PWM states, 
ensuring the desired recovery.


\subsection{UI visualization}

For the UI visualization 2 switches reflecting the current state of LED have been employed 
and a slider for representing the common PWM applied to them.

A new function named \texttt{function4} have been used to do the same operation as 
\texttt{function3} with the difference of returning3 outputs, one by one to be passed
on the switches and the slider.


		\begin{figure}[H]
			\centering
			\includegraphics[width=0.9\textwidth]{ui_conf.png}
			\caption{configuration show for slider of led1.}
			\label{fig1:}
		\end{figure}		

	
	A screenshot of the visualization is presented below, having the 2 switches and the slider,
	and for debug purposes the plots of the incoming data from accelerometer and gyrometer.

		\begin{figure}[H]
			\centering
			\includegraphics[width=0.9\textwidth]{ui_threshold.png}
			\caption{Node-Red UI.}
			\label{fig1:}
		\end{figure}		


\section{Summary of Data Flow}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Component} & \textbf{Topic / Action} & \textbf{Description} \\
\hline
ESP32 & Publish \texttt{esp32/restore\_request} & Sends \texttt{get\_latest} on startup \\
Node-RED & MQTT In on \texttt{esp32/restore\_request} & Detects restore request \\
Node-RED & InfluxDB query & Fetch last saved LED/PWM states \\
Node-RED & Function node & Format restore state payload \\
Node-RED & MQTT Out on \texttt{esp32/restore\_state} & Publishes restore state \\
ESP32 & MQTT Subscribe \texttt{esp32/restore\_state} & Receives and applies restore state \\
ESP32 & Publish \texttt{esp32/status} & Periodic status updates \\
\hline
\end{tabular}
\end{center}



\section{Motion detection via machine learning}

In the second part, the goal is to move from the threshold supported movement detection and achieve the 
operational functionalities by employing machine learning.





\end{document}

